// AUTO-GENERATED by scripts/generate_pending_corpus_tests.sh
// Semantic corpus assertions generated from upstream Haskell fixtures.
// Includes positive, negative, and latent example extraction where available.

#![allow(clippy::needless_raw_string_hashes)]

use chrono::{TimeZone, Utc};
use duckling::{parse, Context, DimensionKind, Lang, Locale, Options, Region};
use regex::Regex;

fn has_content(s: &str) -> bool {
    !s.trim().is_empty()
}

fn unescape_haskell_string(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    let mut chars = s.chars();
    while let Some(ch) = chars.next() {
        if ch == '\\' {
            match chars.next() {
                Some('n') => out.push('\n'),
                Some('t') => out.push('\t'),
                Some('r') => out.push('\r'),
                Some('"') => out.push('"'),
                Some('\\') => out.push('\\'),
                Some('\'') => out.push('\''),
                Some(other) => out.push(other),
                None => break,
            }
        } else {
            out.push(ch);
        }
    }
    out
}

fn extract_binding_block<'a>(corpus: &'a str, binding: &str) -> Option<&'a str> {
    let start_re = Regex::new(&format!(r#"(?m)^{}\b[^\n=]*="#, regex::escape(binding))).ok()?;
    let start = start_re.find(corpus)?.start();
    let tail = &corpus[start..];
    // Next top-level binding starts in column 0.
    let next_re = Regex::new(r#"(?m)^[A-Za-z][A-Za-z0-9_']*\b[^\n=]*="#).ok()?;
    let mut next = None;
    for m in next_re.find_iter(tail) {
        if m.start() > 0 {
            next = Some(m.start());
            break;
        }
    }
    let end = next.unwrap_or(tail.len());
    Some(&tail[..end])
}

fn extract_strings_from_block(block: &str) -> Vec<String> {
    let re = Regex::new(r#"(?m)^\s*(?:\[|,)\s*"((?:\\.|[^"\\])*)""#).expect("string regex");
    re.captures_iter(block)
        .map(|c| unescape_haskell_string(c.get(1).map(|m| m.as_str()).unwrap_or_default()))
        .filter(|s| !s.trim().is_empty())
        .collect()
}

fn extract_all_examples_strings(corpus: &str) -> Vec<String> {
    extract_binding_block(corpus, "allExamples")
        .map(extract_strings_from_block)
        .unwrap_or_default()
}

fn extract_negative_examples_strings(corpus: &str) -> Vec<String> {
    extract_binding_block(corpus, "negativeExamples")
        .map(extract_strings_from_block)
        .unwrap_or_default()
}

fn extract_latent_examples_strings(corpus: &str) -> Vec<String> {
    let from_latent_examples = extract_binding_block(corpus, "latentExamples")
        .map(extract_strings_from_block)
        .unwrap_or_default();
    if !from_latent_examples.is_empty() {
        return from_latent_examples;
    }
    extract_binding_block(corpus, "latentCorpus")
        .map(extract_strings_from_block)
        .unwrap_or_default()
}

fn parse_context(locale: Locale) -> Context {
    Context {
        reference_time: Utc.with_ymd_and_hms(2013, 2, 12, 4, 30, 0).unwrap(),
        locale,
        timezone_offset_minutes: -120,
    }
}

fn dim_from_name(dim: &str) -> DimensionKind {
    match dim {
        "AmountOfMoney" => DimensionKind::AmountOfMoney,
        "CreditCardNumber" => DimensionKind::CreditCardNumber,
        "Distance" => DimensionKind::Distance,
        "Duration" => DimensionKind::Duration,
        "Email" => DimensionKind::Email,
        "Numeral" => DimensionKind::Numeral,
        "Ordinal" => DimensionKind::Ordinal,
        "PhoneNumber" => DimensionKind::PhoneNumber,
        "Quantity" => DimensionKind::Quantity,
        "Temperature" => DimensionKind::Temperature,
        "Time" => DimensionKind::Time,
        "Url" => DimensionKind::Url,
        "Volume" => DimensionKind::Volume,
        _ => panic!("Unknown dimension: {dim}"),
    }
}

fn lang_from_code(code: &str) -> Lang {
    match code {
        "AF" => Lang::AF,
        "AR" => Lang::AR,
        "BG" => Lang::BG,
        "BN" => Lang::BN,
        "CA" => Lang::CA,
        "COMMON" => Lang::EN,
        "CS" => Lang::CS,
        "DA" => Lang::DA,
        "DE" => Lang::DE,
        "EL" => Lang::EL,
        "EN" => Lang::EN,
        "ES" => Lang::ES,
        "ET" => Lang::ET,
        "FA" => Lang::FA,
        "FI" => Lang::FI,
        "FR" => Lang::FR,
        "GA" => Lang::GA,
        "HE" => Lang::HE,
        "HI" => Lang::HI,
        "HR" => Lang::HR,
        "HU" => Lang::HU,
        "ID" => Lang::ID,
        "IS" => Lang::IS,
        "IT" => Lang::IT,
        "JA" => Lang::JA,
        "KA" => Lang::KA,
        "KM" => Lang::KM,
        "KN" => Lang::KN,
        "KO" => Lang::KO,
        "LO" => Lang::LO,
        "ML" => Lang::ML,
        "MN" => Lang::MN,
        "MY" => Lang::MY,
        "NB" => Lang::NB,
        "NE" => Lang::NE,
        "NL" => Lang::NL,
        "PL" => Lang::PL,
        "PT" => Lang::PT,
        "RO" => Lang::RO,
        "RU" => Lang::RU,
        "SK" => Lang::SK,
        "SV" => Lang::SV,
        "SW" => Lang::SW,
        "TA" => Lang::TA,
        "TE" => Lang::TE,
        "TH" => Lang::TH,
        "TR" => Lang::TR,
        "UK" => Lang::UK,
        "VI" => Lang::VI,
        "ZH" => Lang::ZH,
        _ => panic!("Unknown language code: {code}"),
    }
}

fn region_from_code(code: &str) -> Option<Region> {
    match code {
        "-" => None,
        "AR" => Some(Region::AR),
        "US" => Some(Region::US),
        "GB" => Some(Region::GB),
        "AU" => Some(Region::AU),
        "BE" => Some(Region::BE),
        "BZ" => Some(Region::BZ),
        "CA" => Some(Region::CA),
        "CL" => Some(Region::CL),
        "CN" => Some(Region::CN),
        "CO" => Some(Region::CO),
        "EG" => Some(Region::EG),
        "ES" => Some(Region::ES),
        "HK" => Some(Region::HK),
        "IE" => Some(Region::IE),
        "IN" => Some(Region::IN),
        "JM" => Some(Region::JM),
        "MO" => Some(Region::MO),
        "MX" => Some(Region::MX),
        "NZ" => Some(Region::NZ),
        "PE" => Some(Region::PE),
        "PH" => Some(Region::PH),
        "TT" => Some(Region::TT),
        "TW" => Some(Region::TW),
        "VE" => Some(Region::VE),
        "ZA" => Some(Region::ZA),
        _ => None,
    }
}

#[test]
fn pending_amountofmoney_ar_amountofmoney_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ar_amountofmoney_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ar_amountofmoney_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_bg_amountofmoney_bg_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_bg_amountofmoney_bg_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_bg_amountofmoney_bg_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ca_amountofmoney_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ca_amountofmoney_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ca_amountofmoney_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_au_amountofmoney_en_au_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("AU"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_au_amountofmoney_en_au_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("AU"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_au_amountofmoney_en_au_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("AU"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/AU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_bz_amountofmoney_en_bz_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("BZ"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_bz_amountofmoney_en_bz_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("BZ"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_bz_amountofmoney_en_bz_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("BZ"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/BZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ca_amountofmoney_en_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("CA"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ca_amountofmoney_en_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("CA"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ca_amountofmoney_en_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("CA"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_gb_amountofmoney_en_gb_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("GB"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_gb_amountofmoney_en_gb_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("GB"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_gb_amountofmoney_en_gb_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("GB"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/GB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ie_amountofmoney_en_ie_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ie_amountofmoney_en_ie_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ie_amountofmoney_en_ie_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IE"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/IE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_in_amountofmoney_en_in_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IN"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_in_amountofmoney_en_in_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IN"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_in_amountofmoney_en_in_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IN"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/IN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_jm_amountofmoney_en_jm_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("JM"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_jm_amountofmoney_en_jm_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("JM"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_jm_amountofmoney_en_jm_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("JM"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/JM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_nz_amountofmoney_en_nz_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("NZ"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_nz_amountofmoney_en_nz_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("NZ"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_nz_amountofmoney_en_nz_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("NZ"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/NZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ph_amountofmoney_en_ph_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("PH"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ph_amountofmoney_en_ph_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("PH"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_ph_amountofmoney_en_ph_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("PH"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/PH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_tt_amountofmoney_en_tt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("TT"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_tt_amountofmoney_en_tt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("TT"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_tt_amountofmoney_en_tt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("TT"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/TT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_us_amountofmoney_en_us_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("US"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_us_amountofmoney_en_us_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("US"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_us_amountofmoney_en_us_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("US"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/US/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_za_amountofmoney_en_za_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("ZA"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_za_amountofmoney_en_za_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("ZA"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_en_za_amountofmoney_en_za_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("ZA"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/EN/ZA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_es_amountofmoney_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_es_amountofmoney_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_es_amountofmoney_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_fr_amountofmoney_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_fr_amountofmoney_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_fr_amountofmoney_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ga_amountofmoney_ga_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ga_amountofmoney_ga_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ga_amountofmoney_ga_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_he_amountofmoney_he_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_he_amountofmoney_he_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_he_amountofmoney_he_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_hr_amountofmoney_hr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_hr_amountofmoney_hr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_hr_amountofmoney_hr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_id_amountofmoney_id_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_id_amountofmoney_id_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_id_amountofmoney_id_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_it_amountofmoney_it_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_it_amountofmoney_it_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_it_amountofmoney_it_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ka_amountofmoney_ka_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ka_amountofmoney_ka_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ka_amountofmoney_ka_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ko_amountofmoney_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ko_amountofmoney_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ko_amountofmoney_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_mn_amountofmoney_mn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_mn_amountofmoney_mn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_mn_amountofmoney_mn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_nb_amountofmoney_nb_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_nb_amountofmoney_nb_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_nb_amountofmoney_nb_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_nl_amountofmoney_nl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_nl_amountofmoney_nl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_nl_amountofmoney_nl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_pt_amountofmoney_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_pt_amountofmoney_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_pt_amountofmoney_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ro_amountofmoney_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ro_amountofmoney_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ro_amountofmoney_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ru_amountofmoney_ru_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ru_amountofmoney_ru_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_ru_amountofmoney_ru_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_sv_amountofmoney_sv_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_sv_amountofmoney_sv_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_sv_amountofmoney_sv_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_tr_amountofmoney_tr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_tr_amountofmoney_tr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_tr_amountofmoney_tr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_vi_amountofmoney_vi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_vi_amountofmoney_vi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_vi_amountofmoney_vi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_zh_amountofmoney_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_zh_amountofmoney_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_amountofmoney_zh_amountofmoney_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs"
    );
    let dim = dim_from_name("AmountOfMoney");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/AmountOfMoney/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_bg_distance_bg_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/BG/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/BG/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_bg_distance_bg_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/BG/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_bg_distance_bg_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/BG/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ca_distance_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/CA/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ca_distance_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/CA/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ca_distance_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/CA/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_cs_distance_cs_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/CS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/CS/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("CS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/CS/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/CS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_cs_distance_cs_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/CS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/CS/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("CS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/CS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_cs_distance_cs_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/CS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/CS/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("CS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/CS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_de_distance_de_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/DE/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/DE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_de_distance_de_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/DE/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_de_distance_de_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/DE/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_es_distance_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/ES/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_es_distance_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/ES/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_es_distance_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/ES/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_fr_distance_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/FR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_fr_distance_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/FR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_fr_distance_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/FR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ga_distance_ga_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/GA/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/GA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ga_distance_ga_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/GA/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ga_distance_ga_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/GA/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_hr_distance_hr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/HR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/HR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_hr_distance_hr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/HR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_hr_distance_hr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/HR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_it_distance_it_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/IT/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/IT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_it_distance_it_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/IT/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_it_distance_it_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/IT/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_km_distance_km_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/KM/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/KM/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_km_distance_km_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/KM/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_km_distance_km_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/KM/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ko_distance_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/KO/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ko_distance_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/KO/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ko_distance_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/KO/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_mn_distance_mn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/MN/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/MN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_mn_distance_mn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/MN/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_mn_distance_mn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/MN/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_nl_distance_nl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/NL/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/NL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_nl_distance_nl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/NL/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_nl_distance_nl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/NL/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_pt_distance_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/PT/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_pt_distance_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/PT/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_pt_distance_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/PT/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ro_distance_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/RO/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ro_distance_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/RO/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ro_distance_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/RO/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ru_distance_ru_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/RU/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/RU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ru_distance_ru_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/RU/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_ru_distance_ru_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/RU/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_sv_distance_sv_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/SV/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/SV/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_sv_distance_sv_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/SV/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_sv_distance_sv_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/SV/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_tr_distance_tr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/TR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/TR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_tr_distance_tr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/TR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_tr_distance_tr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/TR/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_zh_distance_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Distance/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Distance/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_zh_distance_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Distance/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_distance_zh_distance_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Distance/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Distance/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Distance");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Distance/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ar_duration_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/AR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ar_duration_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/AR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ar_duration_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/AR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_bg_duration_bg_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/BG/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/BG/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_bg_duration_bg_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/BG/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_bg_duration_bg_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/BG/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ca_duration_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/CA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ca_duration_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/CA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ca_duration_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/CA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_de_duration_de_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/DE/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/DE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_de_duration_de_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/DE/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_de_duration_de_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/DE/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_el_duration_el_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/EL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/EL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_el_duration_el_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/EL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_el_duration_el_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/EL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_es_duration_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/ES/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_es_duration_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/ES/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_es_duration_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/ES/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_fr_duration_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/FR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_fr_duration_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/FR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_fr_duration_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/FR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ga_duration_ga_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/GA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/GA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ga_duration_ga_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/GA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ga_duration_ga_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/GA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_hi_duration_hi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/HI/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/HI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_hi_duration_hi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/HI/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_hi_duration_hi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/HI/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_hu_duration_hu_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/HU/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/HU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_hu_duration_hu_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/HU/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_hu_duration_hu_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/HU/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ja_duration_ja_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/JA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/JA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ja_duration_ja_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/JA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ja_duration_ja_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/JA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ka_duration_ka_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/KA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/KA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ka_duration_ka_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/KA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ka_duration_ka_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/KA/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ko_duration_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/KO/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ko_duration_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/KO/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ko_duration_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/KO/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_mn_duration_mn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/MN/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/MN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_mn_duration_mn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/MN/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_mn_duration_mn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/MN/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_nb_duration_nb_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/NB/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/NB/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_nb_duration_nb_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/NB/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_nb_duration_nb_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/NB/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_nl_duration_nl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/NL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/NL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_nl_duration_nl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/NL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_nl_duration_nl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/NL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_pl_duration_pl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/PL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/PL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_pl_duration_pl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/PL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_pl_duration_pl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/PL/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_pt_duration_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/PT/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_pt_duration_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/PT/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_pt_duration_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/PT/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ro_duration_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/RO/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ro_duration_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/RO/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ro_duration_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/RO/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ru_duration_ru_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/RU/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/RU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ru_duration_ru_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/RU/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_ru_duration_ru_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/RU/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_sv_duration_sv_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/SV/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/SV/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_sv_duration_sv_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/SV/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_sv_duration_sv_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/SV/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_tr_duration_tr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/TR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/TR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_tr_duration_tr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/TR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_tr_duration_tr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/TR/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_uk_duration_uk_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/UK/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/UK/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_uk_duration_uk_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/UK/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_uk_duration_uk_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/UK/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_zh_duration_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Duration/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Duration/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_zh_duration_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Duration/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_duration_zh_duration_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Duration/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Duration/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Duration");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Duration/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_common_email_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("COMMON"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Email/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Email/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_common_email_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("COMMON"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Email/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_common_email_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("COMMON"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Email/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_de_email_de_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/DE/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Email/DE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Email/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_de_email_de_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/DE/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Email/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_de_email_de_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/DE/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Email/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_fr_email_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/FR/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Email/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Email/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_fr_email_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/FR/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Email/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_fr_email_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/FR/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Email/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_is_email_is_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/IS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/IS/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("IS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Email/IS/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Email/IS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_is_email_is_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/IS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/IS/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("IS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Email/IS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_is_email_is_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/IS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/IS/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("IS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Email/IS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_it_email_it_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/IT/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Email/IT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Email/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_it_email_it_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/IT/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Email/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_email_it_email_it_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Email/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Email/IT/Corpus.hs"
    );
    let dim = dim_from_name("Email");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Email/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_af_numeral_af_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AF/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AF/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AF"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/AF/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/AF/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_af_numeral_af_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AF/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AF/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AF"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/AF/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_af_numeral_af_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AF/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AF/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AF"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/AF/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ar_numeral_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ar_numeral_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ar_numeral_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ar_eg_numeral_ar_eg_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("EG"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ar_eg_numeral_ar_eg_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("EG"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ar_eg_numeral_ar_eg_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("EG"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/AR/EG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_bg_numeral_bg_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/BG/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/BG/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_bg_numeral_bg_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/BG/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_bg_numeral_bg_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/BG/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_bn_numeral_bn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/BN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/BN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("BN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/BN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/BN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_bn_numeral_bn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/BN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/BN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("BN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/BN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_bn_numeral_bn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/BN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/BN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("BN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/BN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ca_numeral_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/CA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ca_numeral_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/CA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ca_numeral_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/CA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_cs_numeral_cs_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/CS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/CS/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("CS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/CS/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/CS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_cs_numeral_cs_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/CS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/CS/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("CS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/CS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_cs_numeral_cs_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/CS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/CS/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("CS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/CS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_da_numeral_da_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/DA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/DA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_da_numeral_da_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/DA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_da_numeral_da_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/DA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_de_numeral_de_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/DE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/DE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_de_numeral_de_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/DE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_de_numeral_de_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/DE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_el_numeral_el_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/EL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/EL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_el_numeral_el_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/EL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_el_numeral_el_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/EL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_ar_numeral_es_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("AR"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_ar_numeral_es_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("AR"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_ar_numeral_es_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("AR"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_cl_numeral_es_cl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("CL"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_cl_numeral_es_cl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("CL"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_cl_numeral_es_cl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("CL"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/CL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_co_numeral_es_co_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("CO"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_co_numeral_es_co_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("CO"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_co_numeral_es_co_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("CO"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/CO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_numeral_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_numeral_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_numeral_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_es_numeral_es_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("ES"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_es_numeral_es_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("ES"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_es_numeral_es_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("ES"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_mx_numeral_es_mx_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("MX"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_mx_numeral_es_mx_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("MX"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_mx_numeral_es_mx_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("MX"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/MX/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_pe_numeral_es_pe_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("PE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_pe_numeral_es_pe_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("PE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_pe_numeral_es_pe_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("PE"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/PE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_ve_numeral_es_ve_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("VE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_ve_numeral_es_ve_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("VE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_es_ve_numeral_es_ve_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("VE"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ES/VE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_et_numeral_et_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ET/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ET/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ET"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ET/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ET/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_et_numeral_et_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ET/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ET/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ET"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ET/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_et_numeral_et_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ET/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ET/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ET"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ET/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fa_numeral_fa_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/FA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/FA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fa_numeral_fa_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/FA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fa_numeral_fa_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/FA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fi_numeral_fi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/FI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/FI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fi_numeral_fi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/FI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fi_numeral_fi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/FI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fr_numeral_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fr_numeral_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_fr_numeral_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/FR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ga_numeral_ga_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/GA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/GA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ga_numeral_ga_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/GA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ga_numeral_ga_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/GA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_he_numeral_he_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/HE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_he_numeral_he_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_he_numeral_he_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hi_numeral_hi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/HI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hi_numeral_hi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hi_numeral_hi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hr_numeral_hr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/HR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hr_numeral_hr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hr_numeral_hr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hu_numeral_hu_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HU/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/HU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hu_numeral_hu_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HU/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_hu_numeral_hu_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/HU/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_id_numeral_id_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ID/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ID/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_id_numeral_id_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ID/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_id_numeral_id_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ID/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_is_numeral_is_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/IS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/IS/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("IS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/IS/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/IS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_is_numeral_is_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/IS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/IS/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("IS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/IS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_is_numeral_is_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/IS/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/IS/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("IS"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/IS/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_it_numeral_it_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/IT/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/IT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_it_numeral_it_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/IT/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_it_numeral_it_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/IT/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ja_numeral_ja_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/JA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/JA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ja_numeral_ja_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/JA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ja_numeral_ja_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/JA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ka_numeral_ka_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/KA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ka_numeral_ka_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ka_numeral_ka_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_km_numeral_km_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KM/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/KM/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_km_numeral_km_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KM/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_km_numeral_km_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KM/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_kn_numeral_kn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/KN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/KN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_kn_numeral_kn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/KN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_kn_numeral_kn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/KN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ko_numeral_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ko_numeral_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ko_numeral_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/KO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_lo_numeral_lo_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/LO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/LO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("LO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/LO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/LO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_lo_numeral_lo_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/LO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/LO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("LO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/LO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_lo_numeral_lo_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/LO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/LO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("LO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/LO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ml_numeral_ml_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ML/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ML/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ML"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ML/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ML/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ml_numeral_ml_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ML/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ML/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ML"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ML/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ml_numeral_ml_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ML/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ML/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ML"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ML/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_mn_numeral_mn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/MN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/MN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_mn_numeral_mn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/MN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_mn_numeral_mn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/MN/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_my_numeral_my_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/MY/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/MY/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("MY"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/MY/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/MY/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_my_numeral_my_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/MY/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/MY/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("MY"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/MY/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_my_numeral_my_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/MY/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/MY/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("MY"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/MY/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_nb_numeral_nb_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NB/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/NB/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_nb_numeral_nb_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NB/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_nb_numeral_nb_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NB/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ne_numeral_ne_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/NE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/NE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ne_numeral_ne_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/NE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ne_numeral_ne_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/NE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_nl_numeral_nl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/NL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_nl_numeral_nl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_nl_numeral_nl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/NL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_pl_numeral_pl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/PL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/PL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_pl_numeral_pl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/PL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_pl_numeral_pl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/PL/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_pt_numeral_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/PT/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_pt_numeral_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/PT/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_pt_numeral_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/PT/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ro_numeral_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/RO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ro_numeral_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/RO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ro_numeral_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/RO/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ru_numeral_ru_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/RU/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/RU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ru_numeral_ru_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/RU/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ru_numeral_ru_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/RU/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sk_numeral_sk_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SK/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/SK/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/SK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sk_numeral_sk_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SK/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/SK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sk_numeral_sk_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SK/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/SK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sv_numeral_sv_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SV/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/SV/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sv_numeral_sv_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SV/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sv_numeral_sv_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SV/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sw_numeral_sw_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SW/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SW/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SW"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/SW/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/SW/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sw_numeral_sw_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SW/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SW/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SW"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/SW/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_sw_numeral_sw_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/SW/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/SW/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("SW"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/SW/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ta_numeral_ta_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/TA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/TA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ta_numeral_ta_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/TA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_ta_numeral_ta_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TA/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/TA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_te_numeral_te_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/TE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/TE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_te_numeral_te_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/TE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_te_numeral_te_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TE/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/TE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_th_numeral_th_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TH/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/TH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/TH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_th_numeral_th_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TH/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/TH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_th_numeral_th_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TH/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/TH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_tr_numeral_tr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/TR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_tr_numeral_tr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_tr_numeral_tr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/TR/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_uk_numeral_uk_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/UK/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/UK/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_uk_numeral_uk_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/UK/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_uk_numeral_uk_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/UK/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_vi_numeral_vi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/VI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/VI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_vi_numeral_vi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/VI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_vi_numeral_vi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/VI/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_zh_numeral_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Numeral/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Numeral/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_zh_numeral_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Numeral/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_numeral_zh_numeral_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Numeral/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Numeral/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Numeral");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Numeral/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ar_ordinal_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/AR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ar_ordinal_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/AR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ar_ordinal_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/AR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_bg_ordinal_bg_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/BG/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/BG/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_bg_ordinal_bg_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/BG/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_bg_ordinal_bg_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/BG/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ca_ordinal_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/CA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ca_ordinal_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/CA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ca_ordinal_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/CA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_da_ordinal_da_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/DA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/DA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_da_ordinal_da_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/DA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_da_ordinal_da_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/DA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_de_ordinal_de_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/DE/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/DE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_de_ordinal_de_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/DE/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_de_ordinal_de_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/DE/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_el_ordinal_el_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/EL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/EL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_el_ordinal_el_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/EL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_el_ordinal_el_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/EL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_es_ordinal_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ES/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_es_ordinal_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ES/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_es_ordinal_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ES/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_et_ordinal_et_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ET/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ET/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ET"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/ET/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ET/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_et_ordinal_et_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ET/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ET/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ET"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ET/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_et_ordinal_et_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ET/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ET/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ET"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ET/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_fr_ordinal_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/FR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_fr_ordinal_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/FR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_fr_ordinal_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/FR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ga_ordinal_ga_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/GA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/GA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ga_ordinal_ga_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/GA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ga_ordinal_ga_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/GA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_he_ordinal_he_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HE/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/HE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_he_ordinal_he_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HE/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_he_ordinal_he_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HE/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hi_ordinal_hi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HI/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/HI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hi_ordinal_hi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HI/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hi_ordinal_hi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HI/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hr_ordinal_hr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/HR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hr_ordinal_hr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hr_ordinal_hr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hu_ordinal_hu_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HU/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/HU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hu_ordinal_hu_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HU/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_hu_ordinal_hu_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/HU/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_id_ordinal_id_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ID/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/ID/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_id_ordinal_id_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ID/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_id_ordinal_id_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ID/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ID/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ID"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ID/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_it_ordinal_it_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/IT/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/IT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_it_ordinal_it_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/IT/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_it_ordinal_it_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/IT/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ja_ordinal_ja_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/JA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/JA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ja_ordinal_ja_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/JA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ja_ordinal_ja_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/JA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ka_ordinal_ka_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/KA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ka_ordinal_ka_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ka_ordinal_ka_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_km_ordinal_km_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KM/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/KM/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_km_ordinal_km_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KM/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_km_ordinal_km_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KM/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ko_ordinal_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KO/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ko_ordinal_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KO/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ko_ordinal_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/KO/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ml_ordinal_ml_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ML/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ML/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ML"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/ML/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ML/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ml_ordinal_ml_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ML/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ML/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ML"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ML/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ml_ordinal_ml_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ML/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ML/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ML"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ML/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_mn_ordinal_mn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/MN/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/MN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_mn_ordinal_mn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/MN/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_mn_ordinal_mn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/MN/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_nb_ordinal_nb_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/NB/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/NB/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_nb_ordinal_nb_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/NB/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_nb_ordinal_nb_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/NB/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_nl_ordinal_nl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/NL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/NL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_nl_ordinal_nl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/NL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_nl_ordinal_nl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/NL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_pl_ordinal_pl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/PL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/PL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_pl_ordinal_pl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/PL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_pl_ordinal_pl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/PL/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_pt_ordinal_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/PT/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_pt_ordinal_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/PT/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_pt_ordinal_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/PT/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ro_ordinal_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/RO/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ro_ordinal_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/RO/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ro_ordinal_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/RO/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ru_ordinal_ru_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/RU/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/RU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ru_ordinal_ru_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/RU/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ru_ordinal_ru_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/RU/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_sv_ordinal_sv_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/SV/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/SV/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_sv_ordinal_sv_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/SV/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_sv_ordinal_sv_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/SV/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ta_ordinal_ta_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/TA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/TA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("TA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/TA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/TA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ta_ordinal_ta_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/TA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/TA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("TA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/TA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_ta_ordinal_ta_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/TA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/TA/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("TA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/TA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_tr_ordinal_tr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/TR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/TR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_tr_ordinal_tr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/TR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_tr_ordinal_tr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/TR/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_uk_ordinal_uk_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/UK/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/UK/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_uk_ordinal_uk_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/UK/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_uk_ordinal_uk_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/UK/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_vi_ordinal_vi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/VI/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/VI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_vi_ordinal_vi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/VI/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_vi_ordinal_vi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/VI/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_zh_ordinal_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_zh_ordinal_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_ordinal_zh_ordinal_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Ordinal");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Ordinal/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_phonenumber_ar_phonenumber_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs"
    );
    let dim = dim_from_name("PhoneNumber");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_phonenumber_ar_phonenumber_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs"
    );
    let dim = dim_from_name("PhoneNumber");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_phonenumber_ar_phonenumber_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs"
    );
    let dim = dim_from_name("PhoneNumber");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/PhoneNumber/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_phonenumber_pt_phonenumber_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs"
    );
    let dim = dim_from_name("PhoneNumber");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_phonenumber_pt_phonenumber_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs"
    );
    let dim = dim_from_name("PhoneNumber");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_phonenumber_pt_phonenumber_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs"
    );
    let dim = dim_from_name("PhoneNumber");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/PhoneNumber/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ar_quantity_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/AR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ar_quantity_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/AR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ar_quantity_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/AR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_es_quantity_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/ES/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_es_quantity_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/ES/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_es_quantity_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/ES/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_fr_quantity_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/FR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_fr_quantity_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/FR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_fr_quantity_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/FR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_hr_quantity_hr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/HR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/HR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_hr_quantity_hr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/HR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_hr_quantity_hr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/HR/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_km_quantity_km_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/KM/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/KM/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_km_quantity_km_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/KM/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_km_quantity_km_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/KM/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ko_quantity_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/KO/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ko_quantity_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/KO/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ko_quantity_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/KO/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_mn_quantity_mn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/MN/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/MN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_mn_quantity_mn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/MN/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_mn_quantity_mn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/MN/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_nl_quantity_nl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/NL/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/NL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_nl_quantity_nl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/NL/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_nl_quantity_nl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/NL/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_pt_quantity_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/PT/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_pt_quantity_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/PT/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_pt_quantity_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/PT/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ro_quantity_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/RO/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ro_quantity_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/RO/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ro_quantity_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/RO/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ru_quantity_ru_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/RU/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/RU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ru_quantity_ru_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/RU/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_ru_quantity_ru_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/RU/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_zh_quantity_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Quantity/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Quantity/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_zh_quantity_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Quantity/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_quantity_zh_quantity_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Quantity/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Quantity/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Quantity");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Quantity/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ar_temperature_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/AR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ar_temperature_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/AR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ar_temperature_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/AR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ca_temperature_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/CA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ca_temperature_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/CA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ca_temperature_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/CA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_es_temperature_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/ES/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_es_temperature_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/ES/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_es_temperature_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/ES/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_fr_temperature_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/FR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_fr_temperature_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/FR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_fr_temperature_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/FR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ga_temperature_ga_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/GA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/GA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ga_temperature_ga_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/GA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ga_temperature_ga_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/GA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_hi_temperature_hi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/HI/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/HI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_hi_temperature_hi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/HI/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_hi_temperature_hi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/HI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/HI/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("HI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/HI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_hr_temperature_hr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/HR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/HR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_hr_temperature_hr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/HR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_hr_temperature_hr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/HR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_it_temperature_it_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/IT/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/IT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_it_temperature_it_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/IT/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_it_temperature_it_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/IT/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ja_temperature_ja_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/JA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/JA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ja_temperature_ja_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/JA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ja_temperature_ja_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/JA/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_km_temperature_km_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/KM/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/KM/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_km_temperature_km_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/KM/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_km_temperature_km_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/KM/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ko_temperature_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/KO/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ko_temperature_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/KO/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ko_temperature_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/KO/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_mn_temperature_mn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/MN/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/MN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_mn_temperature_mn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/MN/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_mn_temperature_mn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/MN/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_pt_temperature_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/PT/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_pt_temperature_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/PT/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_pt_temperature_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/PT/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ro_temperature_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/RO/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ro_temperature_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/RO/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_ro_temperature_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/RO/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_tr_temperature_tr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/TR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/TR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_tr_temperature_tr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/TR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_tr_temperature_tr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/TR/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_zh_temperature_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Temperature/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Temperature/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_zh_temperature_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Temperature/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_temperature_zh_temperature_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Temperature/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Temperature/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Temperature");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Temperature/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ar_time_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/AR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ar_time_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/AR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ar_time_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/AR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_bg_time_bg_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/BG/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/BG/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_bg_time_bg_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/BG/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_bg_time_bg_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/BG/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/BG/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("BG"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/BG/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ca_time_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/CA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ca_time_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/CA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ca_time_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/CA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_common_time_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("COMMON"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_common_time_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("COMMON"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_common_time_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("COMMON"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_da_time_da_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/DA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/DA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_da_time_da_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/DA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_da_time_da_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/DA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/DA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("DA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/DA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_de_time_de_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/DE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/DE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_de_time_de_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/DE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_de_time_de_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/DE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_el_time_el_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_el_time_el_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_el_time_el_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_au_time_en_au_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/AU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/AU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("AU"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/AU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/AU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_au_time_en_au_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/AU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/AU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("AU"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/AU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_au_time_en_au_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/AU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/AU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("AU"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/AU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_bz_time_en_bz_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("BZ"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_bz_time_en_bz_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("BZ"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_bz_time_en_bz_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("BZ"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/BZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ca_time_en_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/CA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("CA"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ca_time_en_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/CA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("CA"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ca_time_en_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/CA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("CA"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_gb_time_en_gb_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/GB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/GB/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("GB"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/GB/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/GB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_gb_time_en_gb_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/GB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/GB/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("GB"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/GB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_gb_time_en_gb_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/GB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/GB/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("GB"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/GB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ie_time_en_ie_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/IE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/IE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/IE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/IE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ie_time_en_ie_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/IE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/IE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/IE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ie_time_en_ie_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/IE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/IE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IE"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/IE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_in_time_en_in_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/IN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/IN/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IN"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/IN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/IN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_in_time_en_in_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/IN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/IN/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IN"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/IN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_in_time_en_in_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/IN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/IN/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("IN"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/IN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_jm_time_en_jm_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/JM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/JM/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("JM"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/JM/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/JM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_jm_time_en_jm_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/JM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/JM/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("JM"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/JM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_jm_time_en_jm_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/JM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/JM/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("JM"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/JM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_nz_time_en_nz_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("NZ"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_nz_time_en_nz_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("NZ"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_nz_time_en_nz_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("NZ"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/NZ/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ph_time_en_ph_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/PH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/PH/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("PH"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/PH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/PH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ph_time_en_ph_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/PH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/PH/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("PH"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/PH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_ph_time_en_ph_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/PH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/PH/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("PH"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/PH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_tt_time_en_tt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/TT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/TT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("TT"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/TT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/TT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_tt_time_en_tt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/TT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/TT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("TT"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/TT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_tt_time_en_tt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/TT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/TT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("TT"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/TT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_us_time_en_us_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/US/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/US/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("US"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/US/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/US/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_us_time_en_us_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/US/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/US/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("US"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/US/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_us_time_en_us_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/US/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/US/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("US"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/US/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_za_time_en_za_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("ZA"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_za_time_en_za_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("ZA"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_en_za_time_en_za_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("EN"), region_from_code("ZA"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/EN/ZA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_es_time_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ES/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_es_time_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ES/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_es_time_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ES/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_fr_time_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/FR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_fr_time_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/FR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_fr_time_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/FR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ga_time_ga_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/GA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/GA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ga_time_ga_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/GA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ga_time_ga_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/GA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_he_time_he_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/HE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_he_time_he_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_he_time_he_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/HE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_hr_time_hr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/HR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_hr_time_hr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_hr_time_hr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_hu_time_hu_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/HU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_hu_time_hu_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_hu_time_hu_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/HU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/HU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("HU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/HU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_it_time_it_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/IT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/IT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_it_time_it_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/IT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_it_time_it_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/IT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ja_time_ja_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/JA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/JA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ja_time_ja_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/JA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ja_time_ja_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/JA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/JA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("JA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/JA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ka_time_ka_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/KA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/KA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ka_time_ka_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/KA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ka_time_ka_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/KA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/KA/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("KA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/KA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ko_time_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/KO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ko_time_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/KO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ko_time_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/KO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nb_time_nb_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NB/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/NB/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nb_time_nb_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NB/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nb_time_nb_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NB/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NB/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NB"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/NB/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nl_be_time_nl_be_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NL/BE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NL/BE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("BE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/NL/BE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/NL/BE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nl_be_time_nl_be_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NL/BE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NL/BE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("BE"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/NL/BE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nl_be_time_nl_be_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NL/BE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NL/BE/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("BE"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/NL/BE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nl_time_nl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/NL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nl_time_nl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_nl_time_nl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/NL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_pl_time_pl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/PL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/PL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_pl_time_pl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/PL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_pl_time_pl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/PL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/PL/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("PL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/PL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_pt_time_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/PT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_pt_time_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/PT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_pt_time_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/PT/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ro_time_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/RO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ro_time_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/RO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ro_time_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/RO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ru_time_ru_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/RU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/RU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ru_time_ru_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/RU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_ru_time_ru_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/RU/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_sv_time_sv_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/SV/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/SV/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_sv_time_sv_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/SV/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_sv_time_sv_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/SV/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/SV/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("SV"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/SV/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_tr_time_tr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/TR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/TR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_tr_time_tr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/TR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_tr_time_tr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/TR/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_uk_time_uk_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/UK/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/UK/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_uk_time_uk_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/UK/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_uk_time_uk_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/UK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/UK/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("UK"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/UK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_vi_time_vi_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/VI/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/VI/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_vi_time_vi_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/VI/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_vi_time_vi_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/VI/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/VI/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("VI"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/VI/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_cn_time_zh_cn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("CN"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_cn_time_zh_cn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("CN"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_cn_time_zh_cn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("CN"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/CN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_time_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_time_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_time_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_hk_time_zh_hk_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("HK"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_hk_time_zh_hk_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("HK"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_hk_time_zh_hk_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("HK"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/HK/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_mo_time_zh_mo_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("MO"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_mo_time_zh_mo_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("MO"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_mo_time_zh_mo_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("MO"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/MO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_tw_time_zh_tw_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("TW"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_tw_time_zh_tw_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("TW"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_time_zh_tw_time_zh_tw_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs"
    );
    let dim = dim_from_name("Time");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("TW"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Time/ZH/TW/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ar_volume_ar_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/AR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/AR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ar_volume_ar_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/AR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ar_volume_ar_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/AR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/AR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("AR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/AR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ca_volume_ca_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/CA/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/CA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ca_volume_ca_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/CA/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ca_volume_ca_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/CA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/CA/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("CA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/CA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_de_volume_de_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/DE/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/DE/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_de_volume_de_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/DE/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_de_volume_de_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/DE/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/DE/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("DE"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/DE/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_es_volume_es_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/ES/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/ES/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_es_volume_es_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/ES/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_es_volume_es_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/ES/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/ES/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("ES"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/ES/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_fr_volume_fr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/FR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/FR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_fr_volume_fr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/FR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_fr_volume_fr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/FR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/FR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("FR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/FR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ga_volume_ga_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/GA/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/GA/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ga_volume_ga_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/GA/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ga_volume_ga_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/GA/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/GA/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("GA"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/GA/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_hr_volume_hr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/HR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/HR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_hr_volume_hr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/HR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_hr_volume_hr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/HR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/HR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("HR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/HR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_it_volume_it_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/IT/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/IT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_it_volume_it_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/IT/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_it_volume_it_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/IT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/IT/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("IT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/IT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_km_volume_km_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/KM/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/KM/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_km_volume_km_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/KM/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_km_volume_km_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/KM/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/KM/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("KM"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/KM/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ko_volume_ko_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/KO/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/KO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ko_volume_ko_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/KO/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ko_volume_ko_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/KO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/KO/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("KO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/KO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_mn_volume_mn_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/MN/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/MN/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_mn_volume_mn_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/MN/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_mn_volume_mn_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/MN/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/MN/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("MN"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/MN/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_nl_volume_nl_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/NL/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/NL/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_nl_volume_nl_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/NL/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_nl_volume_nl_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/NL/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/NL/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("NL"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/NL/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_pt_volume_pt_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/PT/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/PT/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_pt_volume_pt_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/PT/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_pt_volume_pt_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/PT/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/PT/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("PT"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/PT/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ro_volume_ro_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/RO/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/RO/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ro_volume_ro_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/RO/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ro_volume_ro_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/RO/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/RO/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("RO"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/RO/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ru_volume_ru_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/RU/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/RU/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ru_volume_ru_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/RU/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_ru_volume_ru_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/RU/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/RU/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("RU"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/RU/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_tr_volume_tr_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/TR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/TR/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_tr_volume_tr_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/TR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_tr_volume_tr_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/TR/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/TR/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("TR"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/TR/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_zh_volume_zh_corpus_hs_positive() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_all_examples_strings(corpus);
    assert!(
        !utterances.is_empty(),
        "No utterances extracted from haskell_upstream/Duckling/Volume/ZH/Corpus.hs"
    );
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for utterance '{:?}' from haskell_upstream/Duckling/Volume/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_zh_volume_zh_corpus_hs_negative() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options::default();
    let utterances = extract_negative_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            !has_dim,
            "Unexpected {:?} entity for negative utterance '{:?}' from haskell_upstream/Duckling/Volume/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}

#[test]
fn pending_volume_zh_volume_zh_corpus_hs_latent() {
    let corpus = include_str!("haskell_upstream/Duckling/Volume/ZH/Corpus.hs");
    assert!(
        has_content(corpus),
        "Corpus fixture is empty: haskell_upstream/Duckling/Volume/ZH/Corpus.hs"
    );
    let dim = dim_from_name("Volume");
    let locale = Locale::new(lang_from_code("ZH"), region_from_code("-"));
    let ctx = parse_context(locale);
    let options = Options { with_latent: true };
    let utterances = extract_latent_examples_strings(corpus);
    if utterances.is_empty() {
        return;
    }
    for utterance in utterances {
        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);
        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);
        assert!(
            has_dim,
            "No {:?} entity for latent utterance '{:?}' from haskell_upstream/Duckling/Volume/ZH/Corpus.hs (entities={:?})",
            dim,
            utterance,
            entities
        );
    }
}
