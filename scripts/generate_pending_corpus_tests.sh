#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
PENDING_TSV="$ROOT_DIR/tests/haskell_upstream/pending_corpus.tsv"
OUT_RS="$ROOT_DIR/tests/pending_corpus.rs"

if [[ ! -f "$PENDING_TSV" ]]; then
  echo "Missing pending corpus list: $PENDING_TSV" >&2
  echo "Run scripts/update_porting_status.sh first." >&2
  exit 1
fi

{
  echo "// AUTO-GENERATED by scripts/generate_pending_corpus_tests.sh"
  echo "// Semantic corpus assertions generated from upstream Haskell fixtures."
  echo "// Includes positive, negative, and latent example extraction where available."
  echo
  echo "#![allow(clippy::needless_raw_string_hashes)]"
  echo
  cat <<'RUST_HEADER'
use chrono::{TimeZone, Utc};
use duckling::{parse, Context, DimensionKind, Lang, Locale, Options, Region};
use regex::Regex;

fn has_content(s: &str) -> bool {
    !s.trim().is_empty()
}

fn unescape_haskell_string(s: &str) -> String {
    let mut out = String::with_capacity(s.len());
    let mut chars = s.chars();
    while let Some(ch) = chars.next() {
        if ch == '\\' {
            match chars.next() {
                Some('n') => out.push('\n'),
                Some('t') => out.push('\t'),
                Some('r') => out.push('\r'),
                Some('"') => out.push('"'),
                Some('\\') => out.push('\\'),
                Some('\'') => out.push('\''),
                Some(other) => out.push(other),
                None => break,
            }
        } else {
            out.push(ch);
        }
    }
    out
}

fn extract_binding_block<'a>(corpus: &'a str, binding: &str) -> Option<&'a str> {
    let start_re = Regex::new(&format!(r#"(?m)^{}\b[^\n=]*="#, regex::escape(binding))).ok()?;
    let start = start_re.find(corpus)?.start();
    let tail = &corpus[start..];
    // Next top-level binding starts in column 0.
    let next_re = Regex::new(r#"(?m)^[A-Za-z][A-Za-z0-9_']*\b[^\n=]*="#).ok()?;
    let mut next = None;
    for m in next_re.find_iter(tail) {
        if m.start() > 0 {
            next = Some(m.start());
            break;
        }
    }
    let end = next.unwrap_or(tail.len());
    Some(&tail[..end])
}

fn extract_strings_from_block(block: &str) -> Vec<String> {
    let re = Regex::new(r#"(?m)^\s*(?:\[|,)\s*"((?:\\.|[^"\\])*)""#).expect("string regex");
    re.captures_iter(block)
        .map(|c| unescape_haskell_string(c.get(1).map(|m| m.as_str()).unwrap_or_default()))
        .filter(|s| !s.trim().is_empty())
        .collect()
}

fn extract_all_examples_strings(corpus: &str) -> Vec<String> {
    extract_binding_block(corpus, "allExamples")
        .map(extract_strings_from_block)
        .unwrap_or_default()
}

fn extract_negative_examples_strings(corpus: &str) -> Vec<String> {
    extract_binding_block(corpus, "negativeExamples")
        .map(extract_strings_from_block)
        .unwrap_or_default()
}

fn extract_latent_examples_strings(corpus: &str) -> Vec<String> {
    let from_latent_examples = extract_binding_block(corpus, "latentExamples")
        .map(extract_strings_from_block)
        .unwrap_or_default();
    if !from_latent_examples.is_empty() {
        return from_latent_examples;
    }
    extract_binding_block(corpus, "latentCorpus")
        .map(extract_strings_from_block)
        .unwrap_or_default()
}

fn parse_context(locale: Locale) -> Context {
    Context {
        reference_time: Utc.with_ymd_and_hms(2013, 2, 12, 4, 30, 0).unwrap(),
        locale,
        timezone_offset_minutes: -120,
    }
}

fn dim_from_name(dim: &str) -> DimensionKind {
    match dim {
        "AmountOfMoney" => DimensionKind::AmountOfMoney,
        "CreditCardNumber" => DimensionKind::CreditCardNumber,
        "Distance" => DimensionKind::Distance,
        "Duration" => DimensionKind::Duration,
        "Email" => DimensionKind::Email,
        "Numeral" => DimensionKind::Numeral,
        "Ordinal" => DimensionKind::Ordinal,
        "PhoneNumber" => DimensionKind::PhoneNumber,
        "Quantity" => DimensionKind::Quantity,
        "Temperature" => DimensionKind::Temperature,
        "Time" => DimensionKind::Time,
        "Url" => DimensionKind::Url,
        "Volume" => DimensionKind::Volume,
        _ => panic!("Unknown dimension: {dim}"),
    }
}

fn lang_from_code(code: &str) -> Lang {
    match code {
        "AF" => Lang::AF,
        "AR" => Lang::AR,
        "BG" => Lang::BG,
        "BN" => Lang::BN,
        "CA" => Lang::CA,
        "COMMON" => Lang::EN,
        "CS" => Lang::CS,
        "DA" => Lang::DA,
        "DE" => Lang::DE,
        "EL" => Lang::EL,
        "EN" => Lang::EN,
        "ES" => Lang::ES,
        "ET" => Lang::ET,
        "FA" => Lang::FA,
        "FI" => Lang::FI,
        "FR" => Lang::FR,
        "GA" => Lang::GA,
        "HE" => Lang::HE,
        "HI" => Lang::HI,
        "HR" => Lang::HR,
        "HU" => Lang::HU,
        "ID" => Lang::ID,
        "IS" => Lang::IS,
        "IT" => Lang::IT,
        "JA" => Lang::JA,
        "KA" => Lang::KA,
        "KM" => Lang::KM,
        "KN" => Lang::KN,
        "KO" => Lang::KO,
        "LO" => Lang::LO,
        "ML" => Lang::ML,
        "MN" => Lang::MN,
        "MY" => Lang::MY,
        "NB" => Lang::NB,
        "NE" => Lang::NE,
        "NL" => Lang::NL,
        "PL" => Lang::PL,
        "PT" => Lang::PT,
        "RO" => Lang::RO,
        "RU" => Lang::RU,
        "SK" => Lang::SK,
        "SV" => Lang::SV,
        "SW" => Lang::SW,
        "TA" => Lang::TA,
        "TE" => Lang::TE,
        "TH" => Lang::TH,
        "TR" => Lang::TR,
        "UK" => Lang::UK,
        "VI" => Lang::VI,
        "ZH" => Lang::ZH,
        _ => panic!("Unknown language code: {code}"),
    }
}

fn region_from_code(code: &str) -> Option<Region> {
    match code {
        "-" => None,
        "AR" => Some(Region::AR),
        "US" => Some(Region::US),
        "GB" => Some(Region::GB),
        "AU" => Some(Region::AU),
        "BE" => Some(Region::BE),
        "BZ" => Some(Region::BZ),
        "CA" => Some(Region::CA),
        "CL" => Some(Region::CL),
        "CN" => Some(Region::CN),
        "CO" => Some(Region::CO),
        "EG" => Some(Region::EG),
        "ES" => Some(Region::ES),
        "HK" => Some(Region::HK),
        "IE" => Some(Region::IE),
        "IN" => Some(Region::IN),
        "JM" => Some(Region::JM),
        "MO" => Some(Region::MO),
        "MX" => Some(Region::MX),
        "NZ" => Some(Region::NZ),
        "PE" => Some(Region::PE),
        "PH" => Some(Region::PH),
        "TT" => Some(Region::TT),
        "TW" => Some(Region::TW),
        "VE" => Some(Region::VE),
        "ZA" => Some(Region::ZA),
        _ => None,
    }
}

RUST_HEADER
} > "$OUT_RS"

count=0
while IFS=$'\t' read -r dim lang locale rel; do
  id="$(printf "%s_%s_%s_%s" "$dim" "$lang" "$locale" "$rel" \
    | tr '[:upper:]' '[:lower:]' \
    | sed -E 's#[^a-z0-9]+#_#g' \
    | sed -E 's#_+#_#g' \
    | sed -E 's#^_##; s#_$##')"
  include_path="haskell_upstream/Duckling/$rel"

  {
    echo "#[test]"
    echo "fn pending_${id}_positive() {"
    echo "    let corpus = include_str!(\"$include_path\");"
    echo "    assert!(has_content(corpus), \"Corpus fixture is empty: $include_path\");"
    echo "    let dim = dim_from_name(\"$dim\");"
    echo "    let locale = Locale::new(lang_from_code(\"$lang\"), region_from_code(\"$locale\"));"
    echo "    let ctx = parse_context(locale);"
    echo "    let options = Options::default();"
    echo "    let utterances = extract_all_examples_strings(corpus);"
    echo "    assert!(!utterances.is_empty(), \"No utterances extracted from $include_path\");"
    echo "    for utterance in utterances {"
    echo "        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);"
    echo "        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);"
    echo "        assert!("
    echo "            has_dim,"
    echo "            \"No {:?} entity for utterance '{:?}' from $include_path (entities={:?})\","
    echo "            dim,"
    echo "            utterance,"
    echo "            entities"
    echo "        );"
    echo "    }"
    echo "}"
    echo
    echo "#[test]"
    echo "fn pending_${id}_negative() {"
    echo "    let corpus = include_str!(\"$include_path\");"
    echo "    assert!(has_content(corpus), \"Corpus fixture is empty: $include_path\");"
    echo "    let dim = dim_from_name(\"$dim\");"
    echo "    let locale = Locale::new(lang_from_code(\"$lang\"), region_from_code(\"$locale\"));"
    echo "    let ctx = parse_context(locale);"
    echo "    let options = Options::default();"
    echo "    let utterances = extract_negative_examples_strings(corpus);"
    echo "    if utterances.is_empty() { return; }"
    echo "    for utterance in utterances {"
    echo "        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);"
    echo "        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);"
    echo "        assert!("
    echo "            !has_dim,"
    echo "            \"Unexpected {:?} entity for negative utterance '{:?}' from $include_path (entities={:?})\","
    echo "            dim,"
    echo "            utterance,"
    echo "            entities"
    echo "        );"
    echo "    }"
    echo "}"
    echo
    echo "#[test]"
    echo "fn pending_${id}_latent() {"
    echo "    let corpus = include_str!(\"$include_path\");"
    echo "    assert!(has_content(corpus), \"Corpus fixture is empty: $include_path\");"
    echo "    let dim = dim_from_name(\"$dim\");"
    echo "    let locale = Locale::new(lang_from_code(\"$lang\"), region_from_code(\"$locale\"));"
    echo "    let ctx = parse_context(locale);"
    echo "    let options = Options { with_latent: true };"
    echo "    let utterances = extract_latent_examples_strings(corpus);"
    echo "    if utterances.is_empty() { return; }"
    echo "    for utterance in utterances {"
    echo "        let entities = parse(&utterance, &locale, &[dim], &ctx, &options);"
    echo "        let has_dim = entities.iter().any(|e| e.value.dim_kind() == dim);"
    echo "        assert!("
    echo "            has_dim,"
    echo "            \"No {:?} entity for latent utterance '{:?}' from $include_path (entities={:?})\","
    echo "            dim,"
    echo "            utterance,"
    echo "            entities"
    echo "        );"
    echo "    }"
    echo "}"
    echo
  } >> "$OUT_RS"

  count=$((count + 1))
done < "$PENDING_TSV"

echo "Wrote $OUT_RS with $count tests."
